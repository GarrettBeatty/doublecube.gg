/* THIS (.ts) FILE IS GENERATED BY TypedSignalR.Client.TypeScript */
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
import type { HubConnection, IStreamResult, Subject } from '@microsoft/signalr';
import type { IGameHub, IGameHubClient } from './Backgammon.Server.Hubs.Interfaces';
import type { MoveDto, MatchConfig, RecentOpponentDto, PositionEvaluationDto, BestMovesAnalysisDto, FriendDto, PlayerSearchResultDto, PlayerProfileDto, DailyPuzzleDto, PuzzleResultDto, PuzzleStreakInfo, PuzzleValidMovesRequest, GameState } from '../Backgammon.Server.Models';
import type { MatchLobbyDto, ActiveGameDto, RecentGameDto, CheckerColorDto, DoubleOfferDto, MatchCreatedDto, OpponentJoinedMatchDto, MatchGameStartingDto, MatchUpdateDto, MatchContinuedDto, MatchStatusDto, MatchGameCompletedDto, MatchCompletedDto, MatchInviteDto, MatchSummaryDto, TimeUpdateDto, PlayerTimedOutDto, CorrespondenceMatchInviteDto, CorrespondenceTurnNotificationDto, CorrespondenceLobbyCreatedDto, LobbyCreatedDto } from '../Backgammon.Server.Models.SignalR';
import type { CorrespondenceGamesResponse } from '../Backgammon.Server.Services';


// components

export type Disposable = {
    dispose(): void;
}

export type HubProxyFactory<T> = {
    createHubProxy(connection: HubConnection): T;
}

export type ReceiverRegister<T> = {
    register(connection: HubConnection, receiver: T): Disposable;
}

type ReceiverMethod = {
    methodName: string,
    method: (...args: any[]) => void
}

class ReceiverMethodSubscription implements Disposable {

    public constructor(
        private connection: HubConnection,
        private receiverMethod: ReceiverMethod[]) {
    }

    public readonly dispose = () => {
        for (const it of this.receiverMethod) {
            this.connection.off(it.methodName, it.method);
        }
    }
}

// API

export type HubProxyFactoryProvider = {
    (hubType: "IGameHub"): HubProxyFactory<IGameHub>;
}

export const getHubProxyFactory = ((hubType: string) => {
    if(hubType === "IGameHub") {
        return IGameHub_HubProxyFactory.Instance;
    }
}) as HubProxyFactoryProvider;

export type ReceiverRegisterProvider = {
    (receiverType: "IGameHubClient"): ReceiverRegister<IGameHubClient>;
}

export const getReceiverRegister = ((receiverType: string) => {
    if(receiverType === "IGameHubClient") {
        return IGameHubClient_Binder.Instance;
    }
}) as ReceiverRegisterProvider;

// HubProxy

class IGameHub_HubProxyFactory implements HubProxyFactory<IGameHub> {
    public static Instance = new IGameHub_HubProxyFactory();

    private constructor() {
    }

    public readonly createHubProxy = (connection: HubConnection): IGameHub => {
        return new IGameHub_HubProxy(connection);
    }
}

class IGameHub_HubProxy implements IGameHub {

    public constructor(private connection: HubConnection) {
    }

    public readonly joinGame = async (playerId: string, gameId: string): Promise<void> => {
        return await this.connection.invoke("JoinGame", playerId, gameId);
    }

    public readonly createAnalysisGame = async (): Promise<void> => {
        return await this.connection.invoke("CreateAnalysisGame");
    }

    public readonly createAiGame = async (playerId: string): Promise<void> => {
        return await this.connection.invoke("CreateAiGame", playerId);
    }

    public readonly rollDice = async (): Promise<void> => {
        return await this.connection.invoke("RollDice");
    }

    public readonly makeMove = async (from: number, to: number): Promise<void> => {
        return await this.connection.invoke("MakeMove", from, to);
    }

    public readonly endTurn = async (): Promise<void> => {
        return await this.connection.invoke("EndTurn");
    }

    public readonly undoLastMove = async (): Promise<void> => {
        return await this.connection.invoke("UndoLastMove");
    }

    public readonly abandonGame = async (): Promise<void> => {
        return await this.connection.invoke("AbandonGame");
    }

    public readonly leaveGame = async (): Promise<void> => {
        return await this.connection.invoke("LeaveGame");
    }

    public readonly getGameState = async (): Promise<void> => {
        return await this.connection.invoke("GetGameState");
    }

    public readonly offerDouble = async (): Promise<void> => {
        return await this.connection.invoke("OfferDouble");
    }

    public readonly acceptDouble = async (): Promise<void> => {
        return await this.connection.invoke("AcceptDouble");
    }

    public readonly declineDouble = async (): Promise<void> => {
        return await this.connection.invoke("DeclineDouble");
    }

    public readonly getValidSources = async (): Promise<number[]> => {
        return await this.connection.invoke("GetValidSources");
    }

    public readonly getValidDestinations = async (fromPoint: number): Promise<MoveDto[]> => {
        return await this.connection.invoke("GetValidDestinations", fromPoint);
    }

    public readonly createMatch = async (config: MatchConfig): Promise<void> => {
        return await this.connection.invoke("CreateMatch", config);
    }

    public readonly joinMatch = async (matchId: string): Promise<void> => {
        return await this.connection.invoke("JoinMatch", matchId);
    }

    public readonly continueMatch = async (matchId: string): Promise<void> => {
        return await this.connection.invoke("ContinueMatch", matchId);
    }

    public readonly getMatchStatus = async (matchId: string): Promise<void> => {
        return await this.connection.invoke("GetMatchStatus", matchId);
    }

    public readonly getMyMatches = async (status: string): Promise<void> => {
        return await this.connection.invoke("GetMyMatches", status);
    }

    public readonly getMatchLobbies = async (lobbyType: string): Promise<MatchLobbyDto[]> => {
        return await this.connection.invoke("GetMatchLobbies", lobbyType);
    }

    public readonly getActiveGames = async (limit: number): Promise<ActiveGameDto[]> => {
        return await this.connection.invoke("GetActiveGames", limit);
    }

    public readonly getRecentGames = async (limit: number): Promise<RecentGameDto[]> => {
        return await this.connection.invoke("GetRecentGames", limit);
    }

    public readonly getRecentOpponents = async (limit: number, includeAi: boolean): Promise<RecentOpponentDto[]> => {
        return await this.connection.invoke("GetRecentOpponents", limit, includeAi);
    }

    public readonly getCorrespondenceGames = async (): Promise<CorrespondenceGamesResponse> => {
        return await this.connection.invoke("GetCorrespondenceGames");
    }

    public readonly createCorrespondenceMatch = async (config: MatchConfig): Promise<void> => {
        return await this.connection.invoke("CreateCorrespondenceMatch", config);
    }

    public readonly notifyCorrespondenceTurnComplete = async (matchId: string, nextPlayerId: string): Promise<void> => {
        return await this.connection.invoke("NotifyCorrespondenceTurnComplete", matchId, nextPlayerId);
    }

    public readonly setDice = async (die1: number, die2: number): Promise<void> => {
        return await this.connection.invoke("SetDice", die1, die2);
    }

    public readonly setCurrentPlayer = async (color: CheckerColorDto): Promise<void> => {
        return await this.connection.invoke("SetCurrentPlayer", color);
    }

    public readonly moveCheckerDirectly = async (from: number, to: number): Promise<void> => {
        return await this.connection.invoke("MoveCheckerDirectly", from, to);
    }

    public readonly exportPosition = async (): Promise<string> => {
        return await this.connection.invoke("ExportPosition");
    }

    public readonly importPosition = async (positionData: string): Promise<void> => {
        return await this.connection.invoke("ImportPosition", positionData);
    }

    public readonly analyzePosition = async (gameId: string, evaluatorType: string): Promise<PositionEvaluationDto> => {
        return await this.connection.invoke("AnalyzePosition", gameId, evaluatorType);
    }

    public readonly findBestMoves = async (gameId: string, evaluatorType: string): Promise<BestMovesAnalysisDto> => {
        return await this.connection.invoke("FindBestMoves", gameId, evaluatorType);
    }

    public readonly sendChatMessage = async (message: string): Promise<void> => {
        return await this.connection.invoke("SendChatMessage", message);
    }

    public readonly getFriends = async (): Promise<FriendDto[]> => {
        return await this.connection.invoke("GetFriends");
    }

    public readonly getFriendRequests = async (): Promise<FriendDto[]> => {
        return await this.connection.invoke("GetFriendRequests");
    }

    public readonly searchPlayers = async (query: string): Promise<PlayerSearchResultDto[]> => {
        return await this.connection.invoke("SearchPlayers", query);
    }

    public readonly sendFriendRequest = async (toUserId: string): Promise<boolean> => {
        return await this.connection.invoke("SendFriendRequest", toUserId);
    }

    public readonly acceptFriendRequest = async (friendUserId: string): Promise<boolean> => {
        return await this.connection.invoke("AcceptFriendRequest", friendUserId);
    }

    public readonly declineFriendRequest = async (friendUserId: string): Promise<boolean> => {
        return await this.connection.invoke("DeclineFriendRequest", friendUserId);
    }

    public readonly removeFriend = async (friendUserId: string): Promise<boolean> => {
        return await this.connection.invoke("RemoveFriend", friendUserId);
    }

    public readonly getPlayerProfile = async (username: string): Promise<PlayerProfileDto> => {
        return await this.connection.invoke("GetPlayerProfile", username);
    }

    public readonly getDailyPuzzle = async (): Promise<DailyPuzzleDto> => {
        return await this.connection.invoke("GetDailyPuzzle");
    }

    public readonly submitPuzzleAnswer = async (moves: MoveDto[]): Promise<PuzzleResultDto> => {
        return await this.connection.invoke("SubmitPuzzleAnswer", moves);
    }

    public readonly giveUpPuzzle = async (): Promise<PuzzleResultDto> => {
        return await this.connection.invoke("GiveUpPuzzle");
    }

    public readonly getPuzzleStreak = async (): Promise<PuzzleStreakInfo> => {
        return await this.connection.invoke("GetPuzzleStreak");
    }

    public readonly getHistoricalPuzzle = async (date: string): Promise<DailyPuzzleDto> => {
        return await this.connection.invoke("GetHistoricalPuzzle", date);
    }

    public readonly getPuzzleValidMoves = async (request: PuzzleValidMovesRequest): Promise<MoveDto[]> => {
        return await this.connection.invoke("GetPuzzleValidMoves", request);
    }
}


// Receiver

class IGameHubClient_Binder implements ReceiverRegister<IGameHubClient> {

    public static Instance = new IGameHubClient_Binder();

    private constructor() {
    }

    public readonly register = (connection: HubConnection, receiver: IGameHubClient): Disposable => {

        const __gameUpdate = (...args: [GameState]) => receiver.gameUpdate(...args);
        const __gameStart = (...args: [GameState]) => receiver.gameStart(...args);
        const __gameOver = (...args: [GameState]) => receiver.gameOver(...args);
        const __waitingForOpponent = (...args: [string]) => receiver.waitingForOpponent(...args);
        const __opponentJoined = (...args: [string]) => receiver.opponentJoined(...args);
        const __opponentLeft = () => receiver.opponentLeft();
        const __spectatorJoined = (...args: [GameState]) => receiver.spectatorJoined(...args);
        const __doubleOffered = (...args: [DoubleOfferDto]) => receiver.doubleOffered(...args);
        const __doubleAccepted = (...args: [GameState]) => receiver.doubleAccepted(...args);
        const __receiveChatMessage = (...args: [string, string, string]) => receiver.receiveChatMessage(...args);
        const __error = (...args: [string]) => receiver.error(...args);
        const __info = (...args: [string]) => receiver.info(...args);
        const __matchCreated = (...args: [MatchCreatedDto]) => receiver.matchCreated(...args);
        const __opponentJoinedMatch = (...args: [OpponentJoinedMatchDto]) => receiver.opponentJoinedMatch(...args);
        const __matchGameStarting = (...args: [MatchGameStartingDto]) => receiver.matchGameStarting(...args);
        const __matchUpdate = (...args: [MatchUpdateDto]) => receiver.matchUpdate(...args);
        const __matchContinued = (...args: [MatchContinuedDto]) => receiver.matchContinued(...args);
        const __matchStatus = (...args: [MatchStatusDto]) => receiver.matchStatus(...args);
        const __matchGameCompleted = (...args: [MatchGameCompletedDto]) => receiver.matchGameCompleted(...args);
        const __matchCompleted = (...args: [MatchCompletedDto]) => receiver.matchCompleted(...args);
        const __matchInvite = (...args: [MatchInviteDto]) => receiver.matchInvite(...args);
        const __myMatches = (...args: [MatchSummaryDto[]]) => receiver.myMatches(...args);
        const __timeUpdate = (...args: [TimeUpdateDto]) => receiver.timeUpdate(...args);
        const __playerTimedOut = (...args: [PlayerTimedOutDto]) => receiver.playerTimedOut(...args);
        const __correspondenceMatchInvite = (...args: [CorrespondenceMatchInviteDto]) => receiver.correspondenceMatchInvite(...args);
        const __correspondenceTurnNotification = (...args: [CorrespondenceTurnNotificationDto]) => receiver.correspondenceTurnNotification(...args);
        const __correspondenceLobbyCreated = (...args: [CorrespondenceLobbyCreatedDto]) => receiver.correspondenceLobbyCreated(...args);
        const __lobbyCreated = (...args: [LobbyCreatedDto]) => receiver.lobbyCreated(...args);
        const __friendRequestReceived = () => receiver.friendRequestReceived();
        const __friendRequestAccepted = () => receiver.friendRequestAccepted();

        connection.on("GameUpdate", __gameUpdate);
        connection.on("GameStart", __gameStart);
        connection.on("GameOver", __gameOver);
        connection.on("WaitingForOpponent", __waitingForOpponent);
        connection.on("OpponentJoined", __opponentJoined);
        connection.on("OpponentLeft", __opponentLeft);
        connection.on("SpectatorJoined", __spectatorJoined);
        connection.on("DoubleOffered", __doubleOffered);
        connection.on("DoubleAccepted", __doubleAccepted);
        connection.on("ReceiveChatMessage", __receiveChatMessage);
        connection.on("Error", __error);
        connection.on("Info", __info);
        connection.on("MatchCreated", __matchCreated);
        connection.on("OpponentJoinedMatch", __opponentJoinedMatch);
        connection.on("MatchGameStarting", __matchGameStarting);
        connection.on("MatchUpdate", __matchUpdate);
        connection.on("MatchContinued", __matchContinued);
        connection.on("MatchStatus", __matchStatus);
        connection.on("MatchGameCompleted", __matchGameCompleted);
        connection.on("MatchCompleted", __matchCompleted);
        connection.on("MatchInvite", __matchInvite);
        connection.on("MyMatches", __myMatches);
        connection.on("TimeUpdate", __timeUpdate);
        connection.on("PlayerTimedOut", __playerTimedOut);
        connection.on("CorrespondenceMatchInvite", __correspondenceMatchInvite);
        connection.on("CorrespondenceTurnNotification", __correspondenceTurnNotification);
        connection.on("CorrespondenceLobbyCreated", __correspondenceLobbyCreated);
        connection.on("LobbyCreated", __lobbyCreated);
        connection.on("FriendRequestReceived", __friendRequestReceived);
        connection.on("FriendRequestAccepted", __friendRequestAccepted);

        const methodList: ReceiverMethod[] = [
            { methodName: "GameUpdate", method: __gameUpdate },
            { methodName: "GameStart", method: __gameStart },
            { methodName: "GameOver", method: __gameOver },
            { methodName: "WaitingForOpponent", method: __waitingForOpponent },
            { methodName: "OpponentJoined", method: __opponentJoined },
            { methodName: "OpponentLeft", method: __opponentLeft },
            { methodName: "SpectatorJoined", method: __spectatorJoined },
            { methodName: "DoubleOffered", method: __doubleOffered },
            { methodName: "DoubleAccepted", method: __doubleAccepted },
            { methodName: "ReceiveChatMessage", method: __receiveChatMessage },
            { methodName: "Error", method: __error },
            { methodName: "Info", method: __info },
            { methodName: "MatchCreated", method: __matchCreated },
            { methodName: "OpponentJoinedMatch", method: __opponentJoinedMatch },
            { methodName: "MatchGameStarting", method: __matchGameStarting },
            { methodName: "MatchUpdate", method: __matchUpdate },
            { methodName: "MatchContinued", method: __matchContinued },
            { methodName: "MatchStatus", method: __matchStatus },
            { methodName: "MatchGameCompleted", method: __matchGameCompleted },
            { methodName: "MatchCompleted", method: __matchCompleted },
            { methodName: "MatchInvite", method: __matchInvite },
            { methodName: "MyMatches", method: __myMatches },
            { methodName: "TimeUpdate", method: __timeUpdate },
            { methodName: "PlayerTimedOut", method: __playerTimedOut },
            { methodName: "CorrespondenceMatchInvite", method: __correspondenceMatchInvite },
            { methodName: "CorrespondenceTurnNotification", method: __correspondenceTurnNotification },
            { methodName: "CorrespondenceLobbyCreated", method: __correspondenceLobbyCreated },
            { methodName: "LobbyCreated", method: __lobbyCreated },
            { methodName: "FriendRequestReceived", method: __friendRequestReceived },
            { methodName: "FriendRequestAccepted", method: __friendRequestAccepted }
        ]

        return new ReceiverMethodSubscription(connection, methodList);
    }
}

