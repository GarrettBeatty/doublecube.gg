name: Deploy to AWS

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: us-east-1
  ENVIRONMENT: dev

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write  # Required for OIDC
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsDeployRole
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and push Server image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker buildx build \
          --platform linux/arm64 \
          --push \
          -f Backgammon.Server/Dockerfile \
          -t $ECR_REGISTRY/backgammon-server-$ENVIRONMENT:$IMAGE_TAG \
          -t $ECR_REGISTRY/backgammon-server-$ENVIRONMENT:latest \
          .

    - name: Build and push WebClient image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker buildx build \
          --platform linux/arm64 \
          --push \
          -f Backgammon.WebClient/Dockerfile \
          -t $ECR_REGISTRY/backgammon-webclient-$ENVIRONMENT:$IMAGE_TAG \
          -t $ECR_REGISTRY/backgammon-webclient-$ENVIRONMENT:latest \
          .

    - name: Deploy to EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
      run: |
        # Setup SSH
        mkdir -p ~/.ssh
        echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key

        # Add EC2 host to known_hosts
        ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts

        # Copy docker-compose and Caddyfile to EC2
        scp -i ~/.ssh/deploy_key docker-compose.prod.yml ec2-user@$EC2_HOST:~/backgammon/
        scp -i ~/.ssh/deploy_key Caddyfile ec2-user@$EC2_HOST:~/backgammon/

        # Deploy on EC2
        ssh -i ~/.ssh/deploy_key ec2-user@$EC2_HOST << 'ENDSSH'
          set -e
          cd ~/backgammon

          # Login to ECR
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}

          # Export environment variables
          export ECR_REGISTRY=${{ env.ECR_REGISTRY }}
          export IMAGE_TAG=latest
          export ENVIRONMENT=dev
          export AWS_REGION=us-east-1
          export DYNAMODB_TABLE_NAME=$(aws ssm get-parameter --name /backgammon/dev/table-name --query Parameter.Value --output text)
          export JWT_SECRET=$(aws ssm get-parameter --name /backgammon/dev/jwt-secret --with-decryption --query Parameter.Value --output text)
          export DOMAIN=$(aws ssm get-parameter --name /backgammon/dev/domain --query Parameter.Value --output text)
          export TLS_EMAIL=$(aws ssm get-parameter --name /backgammon/dev/tls-email --query Parameter.Value --output text)

          # Pull new images
          docker-compose -f docker-compose.prod.yml pull

          # Ensure Redis is running (required for SignalR backplane)
          echo "Starting Redis if not already running..."
          docker-compose -f docker-compose.prod.yml up -d redis

          # Wait for Redis to be healthy
          echo "Waiting for Redis to become healthy..."
          for i in {1..30}; do
            HEALTH=$(docker inspect --format='{{.State.Health.Status}}' backgammon-redis 2>/dev/null || echo "unknown")
            if [ "$HEALTH" = "healthy" ]; then
              echo "✓ Redis is healthy"
              break
            fi
            echo "Attempt $i/30: Redis status = $HEALTH"
            sleep 2
          done

          # Rolling update strategy for zero downtime
          echo "Starting rolling update..."

          # Update server-1 first
          echo "Updating server-1..."
          docker-compose -f docker-compose.prod.yml up -d --no-deps server-1

          # Wait for server-1 to be healthy (using docker health check)
          echo "Waiting for server-1 to become healthy..."
          for i in {1..60}; do
            HEALTH=$(docker inspect --format='{{.State.Health.Status}}' backgammon-server-1 2>/dev/null || echo "unknown")
            if [ "$HEALTH" = "healthy" ]; then
              echo "✓ server-1 is healthy"
              break
            fi
            echo "Attempt $i/60: server-1 status = $HEALTH"
            sleep 2
          done

          # Give it extra time to stabilize
          sleep 5

          # Update server-2
          echo "Updating server-2..."
          docker-compose -f docker-compose.prod.yml up -d --no-deps server-2

          # Wait for server-2 to be healthy (using docker health check)
          echo "Waiting for server-2 to become healthy..."
          for i in {1..60}; do
            HEALTH=$(docker inspect --format='{{.State.Health.Status}}' backgammon-server-2 2>/dev/null || echo "unknown")
            if [ "$HEALTH" = "healthy" ]; then
              echo "✓ server-2 is healthy"
              break
            fi
            echo "Attempt $i/60: server-2 status = $HEALTH"
            sleep 2
          done

          # Give it extra time to stabilize
          sleep 5

          # Update webclient
          echo "Updating webclient..."
          docker-compose -f docker-compose.prod.yml up -d --no-deps webclient

          # Wait for webclient to be healthy
          echo "Waiting for webclient to become healthy..."
          for i in {1..60}; do
            HEALTH=$(docker inspect --format='{{.State.Health.Status}}' backgammon-webclient 2>/dev/null || echo "unknown")
            if [ "$HEALTH" = "healthy" ]; then
              echo "✓ webclient is healthy"
              break
            fi
            echo "Attempt $i/60: webclient status = $HEALTH"
            sleep 2
          done

          # Update Caddy (reload config - no restart needed)
          echo "Reloading Caddy configuration..."
          docker exec backgammon-caddy caddy reload --config /etc/caddy/Caddyfile || true

          # Final health check
          echo "Deployment complete! Final status:"
          docker ps --format 'table {{.Names}}\t{{.Status}}'

          # Cleanup old images
          docker image prune -af --filter "until=24h"

          echo "Deployment complete!"
        ENDSSH

    - name: Verify deployment
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
      run: |
        # Check if services are running
        ssh -i ~/.ssh/deploy_key ec2-user@$EC2_HOST << 'ENDSSH'
          docker ps
          echo "---"
          echo "Service health:"
          curl -f http://localhost:5000/health || echo "Server health check failed"
          echo "Server: OK"
        ENDSSH
